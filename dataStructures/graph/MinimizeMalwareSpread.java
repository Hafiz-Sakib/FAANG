import java.util.Arrays;

/**
 * Created on:  Dec 19, 2020
 * Questions: https://leetcode.com/problems/minimize-malware-spread/
 */

public class MinimizeMalwareSpread {

    public static void main(String[] args) {
//        println minMalwareSpread([[1, 1, 0], [1, 1, 0], [0, 0, 1]] as int[][], [0, 1, 2] as int[])
    }

    static int minMalwareSpread(int[][] graph, int[] initial) {
//        Add colour to each node, and all the linked nodes.
        int[] colors = new int[graph.length];
        Arrays.fill(colors, -1);
        int col = 0;
        for (int i = 0; i < graph.length; i++) {
//            If not colored then go and colour all the linked nodes.
            if (colors[i] == -1) {
                dfs(graph, colors, i, col++);
            }
        }
//        Find the count of each colour.
        int[] count = new int[col];
        for (int c : colors) {
            count[c]++;
        }
//        Find unique colors.
        int[] colorCount = new int[col];
        for (int node : initial)
            colorCount[colors[node]]++;

//        Initialize the op to -1;
        int op = -1, minInfectedNode = Integer.MAX_VALUE;
//        Loop through all the infected nodes and get the node that can infect the max.
        for (int node : initial) {
//            Check only the uniqly coloured initial infects
            if (colorCount[colors[node]] != 1) continue;
//            There will be three case.
//              1. It is the first infected node,
//              2. If the current node can infect more than the previous best node,
//              3. If infecting same amount, take the smaller node.
            if (op == -1 || count[colors[op]] < count[colors[node]] || (count[colors[op]] == count[colors[node]] && op > node)) {
                op = node;
            }
            minInfectedNode = Math.min(minInfectedNode, node);
        }
        return op == -1 ? minInfectedNode : op;
    }

    private static void dfs(int[][] graph, int[] colours, int cur, int col) {
        if (colours[cur] != -1) return;
        colours[cur] = col;
        for (int i = 0; i < graph.length; i++) {
            if (graph[cur][i] == 1)
                dfs(graph, colours, i, col);
        }
    }
}
